name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

jobs:
  lint-workflows:
    name: Lint Workflows
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Install actionlint
        run: |
          # actionlint v1.7.9 - https://github.com/rhysd/actionlint/releases/tag/v1.7.9
          ACTIONLINT_VERSION="1.7.9"
          ACTIONLINT_CHECKSUM="233b280d05e100837f4af1433c7b40a5dcb306e3aa68fb4f17f8a7f45a7df7b4"
          
          curl -sL "https://github.com/rhysd/actionlint/releases/download/v${ACTIONLINT_VERSION}/actionlint_${ACTIONLINT_VERSION}_linux_amd64.tar.gz" -o actionlint.tar.gz
          echo "${ACTIONLINT_CHECKSUM}  actionlint.tar.gz" | sha256sum -c
          tar xz -C /tmp actionlint < actionlint.tar.gz
          sudo mv /tmp/actionlint /usr/local/bin/
          rm actionlint.tar.gz

      - name: Lint all workflows
        run: |
          echo "Linting all workflow files..."
          # Ignore SC2086 (double quote to prevent globbing) - common in GHA workflows
          # where variables like $GITHUB_STEP_SUMMARY are known-safe
          actionlint -ignore 'SC2086' -ignore 'SC2129' -color
          echo "✅ All workflows pass linting"

  validate-expressions:
    name: Validate Workflow Expressions
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Check for dangerous input comparison patterns
        run: |
          echo "Checking for dangerous boolean comparison patterns..."
          echo "These break when inputs are null (not provided)"
          echo ""
          
          ERRORS=0
          
          for workflow in .github/workflows/*.yml; do
            # Skip ci.yml since it contains the patterns in documentation/grep commands
            if [ "$workflow" = ".github/workflows/ci.yml" ]; then
              continue
            fi
            
            echo "Checking $workflow..."
            
            # Pattern: inputs.X == false (breaks when null)
            # Only match in 'if:' conditions, not in echo/grep commands
            if grep -E '^\s+if:.*inputs\.[a-z_]+ == false' "$workflow" 2>/dev/null || \
               grep -E '^\s+if: \|' -A5 "$workflow" 2>/dev/null | grep -E 'inputs\.[a-z_]+ == false' 2>/dev/null; then
              echo "❌ ERROR in $workflow: Found 'inputs.X == false' in condition"
              echo "   This returns false when inputs are null. Use 'inputs.X != true' instead."
              ERRORS=$((ERRORS + 1))
            fi
            
            # Pattern: inputs.auto_fix_tests == true (default is true, breaks when null)
            if grep -E '^\s+if:.*inputs\.auto_fix_tests == true' "$workflow" 2>/dev/null || \
               grep -E '^\s+if: \|' -A5 "$workflow" 2>/dev/null | grep -E 'inputs\.auto_fix_tests == true' 2>/dev/null; then
              echo "❌ ERROR in $workflow: Found 'inputs.auto_fix_tests == true' in condition"
              echo "   Default is true, but null == true is false. Use 'inputs.auto_fix_tests != false' instead."
              ERRORS=$((ERRORS + 1))
            fi
          done
          
          if [ $ERRORS -gt 0 ]; then
            echo ""
            echo "❌ Found $ERRORS dangerous pattern(s)"
            exit 1
          fi
          
          echo "✅ No dangerous input comparison patterns found"

      - name: Validate GitHub Actions expression logic
        run: |
          echo "Testing expression evaluation behavior..."
          
          # Test that our patterns work correctly
          test_pattern() {
            local desc="$1"
            local expected="$2"
            local actual="$3"
            
            if [ "$expected" = "$actual" ]; then
              echo "✅ $desc"
            else
              echo "❌ $desc (expected: $expected, got: $actual)"
              return 1
            fi
          }
          
          FAILURES=0
          
          # Test: != true pattern (for dry_run with default=false)
          VAL=""  # null/unset
          [ "$VAL" != "true" ] && R="true" || R="false"
          test_pattern "null != true → true (dry_run unset should run)" "true" "$R" || FAILURES=$((FAILURES+1))
          
          VAL="false"
          [ "$VAL" != "true" ] && R="true" || R="false"
          test_pattern "false != true → true (dry_run=false should run)" "true" "$R" || FAILURES=$((FAILURES+1))
          
          VAL="true"
          [ "$VAL" != "true" ] && R="true" || R="false"
          test_pattern "true != true → false (dry_run=true should skip)" "false" "$R" || FAILURES=$((FAILURES+1))
          
          # Test: != false pattern (for auto_fix_tests with default=true)
          VAL=""
          [ "$VAL" != "false" ] && R="true" || R="false"
          test_pattern "null != false → true (auto_fix unset should run)" "true" "$R" || FAILURES=$((FAILURES+1))
          
          VAL="true"
          [ "$VAL" != "false" ] && R="true" || R="false"
          test_pattern "true != false → true (auto_fix=true should run)" "true" "$R" || FAILURES=$((FAILURES+1))
          
          VAL="false"
          [ "$VAL" != "false" ] && R="true" || R="false"
          test_pattern "false != false → false (auto_fix=false should skip)" "false" "$R" || FAILURES=$((FAILURES+1))
          
          if [ $FAILURES -gt 0 ]; then
            echo "❌ $FAILURES expression test(s) failed"
            exit 1
          fi
          
          echo "✅ All expression tests passed"

  validate-repo-config:
    name: Validate Repo Configuration
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Check repo-config.json is valid JSON
        run: |
          echo "Validating repo-config.json..."
          
          if [ ! -f "repo-config.json" ]; then
            echo "❌ Missing repo-config.json"
            exit 1
          fi
          
          if ! jq empty repo-config.json 2>/dev/null; then
            echo "❌ repo-config.json is not valid JSON"
            exit 1
          fi
          
          echo "✅ repo-config.json is valid JSON"

      - name: Validate scripts exist and are executable
        run: |
          echo "Checking management scripts..."
          
          ERRORS=0
          
          for script in scripts/sync-files scripts/configure-repos scripts/sync-secrets; do
            if [ ! -f "$script" ]; then
              echo "❌ Missing script: $script"
              ERRORS=$((ERRORS + 1))
            elif [ ! -x "$script" ]; then
              echo "❌ Script not executable: $script"
              ERRORS=$((ERRORS + 1))
            else
              echo "✅ $script"
            fi
          done
          
          if [ $ERRORS -gt 0 ]; then
            echo "❌ $ERRORS script error(s)"
            exit 1
          fi
          
          echo "✅ All management scripts are valid"

      - name: Validate repository-files source paths
        run: |
          echo "Checking that repository-files source paths exist..."
          
          ERRORS=0
          
          # Check always-sync files
          for file in repository-files/always-sync/.cursor/rules/*.mdc; do
            if [ -f "$file" ]; then
              echo "✅ $file"
            fi
          done
          
          # Check language-specific files
          for file in repository-files/python/.cursor/rules/python.mdc \
                      repository-files/nodejs/.cursor/rules/typescript.mdc \
                      repository-files/go/.cursor/rules/go.mdc \
                      repository-files/terraform/.cursor/rules/terraform.mdc; do
            if [ ! -f "$file" ]; then
              echo "❌ Missing language rule: $file"
              ERRORS=$((ERRORS + 1))
            else
              echo "✅ $file"
            fi
          done
          
          if [ $ERRORS -gt 0 ]; then
            echo ""
            echo "❌ $ERRORS source path(s) do not exist"
            exit 1
          fi
          
          echo ""
          echo "✅ All repository-files source paths exist"

  validate-repository-files:
    name: Validate Repository Files
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Check repository-files structure
        run: |
          echo "Validating repository-files directory structure..."
          
          ERRORS=0
          
          # Check required directories exist
          for dir in repository-files/always-sync repository-files/initial-only; do
            if [ ! -d "$dir" ]; then
              echo "❌ Missing required directory: $dir"
              ERRORS=$((ERRORS + 1))
            else
              echo "✅ $dir exists"
            fi
          done
          
          # Check cursor rules are valid
          for rule in repository-files/always-sync/.cursor/rules/*.mdc; do
            if [ -f "$rule" ]; then
              # Basic validation - file should not be empty
              if [ ! -s "$rule" ]; then
                echo "❌ Empty cursor rule: $rule"
                ERRORS=$((ERRORS + 1))
              else
                echo "✅ $rule"
              fi
            fi
          done
          
          if [ $ERRORS -gt 0 ]; then
            echo "❌ $ERRORS validation error(s)"
            exit 1
          fi
          
          echo "✅ Repository files structure is valid"

  dry-run-generate-tests:
    name: Dry Run - Generate Tests Workflow
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      # actions/setup-python v6.1.0
      - name: Set up Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548
        with:
          python-version: "3.12"

      - name: Validate discover_modules.py logic
        run: |
          echo "Testing module discovery logic..."
          
          # Create a minimal test structure using printf to avoid heredoc indentation issues
          # Note: Using 'sample_pkg' not 'test_pkg' to avoid matching the "test_" skip pattern
          mkdir -p sample_pkg
          printf '%s\n' '"""Sample package."""' 'def hello():' '    pass' > sample_pkg/__init__.py
          printf '%s\n' '"""Sample module."""' 'class SampleClass:' '    def method(self):' '        pass' '' 'def sample_func():' '    pass' > sample_pkg/module.py
          
          # Extract and run the discovery logic from generate-tests.yml
          python3 << 'PYTEST'
          import os
          import json
          import sys
          from pathlib import Path
          import ast
          
          def get_package_dirs():
              packages = []
              if Path("src").is_dir():
                  for item in Path("src").iterdir():
                      if item.is_dir() and (item / "__init__.py").exists():
                          packages.append(str(item))
              for item in Path(".").iterdir():
                  if item.is_dir() and item.name not in ("tests", "test", "docs", "build", "dist", ".git", ".venv", "venv", "__pycache__", ".tox", "htmlcov", "src", ".github"):
                      if (item / "__init__.py").exists():
                          packages.append(str(item))
              return packages or ["."]
          
          def find_python_modules(package_dirs):
              modules = []
              for pkg_dir in package_dirs:
                  pkg_path = Path(pkg_dir)
                  for py_file in pkg_path.rglob("*.py"):
                      rel_path = str(py_file)
                      if any(x in rel_path for x in ["__pycache__", "test_", "_test.py", "tests/", "test/", "conftest.py"]):
                          continue
                      if py_file.name.startswith("_") and py_file.name != "__init__.py":
                          continue
                      try:
                          with open(py_file, "r", encoding="utf-8") as f:
                              content = f.read()
                          tree = ast.parse(content)
                          funcs = sum(1 for n in ast.walk(tree) if isinstance(n, ast.FunctionDef))
                          classes = sum(1 for n in ast.walk(tree) if isinstance(n, ast.ClassDef))
                          if funcs > 0 or classes > 0:
                              modules.append({
                                  "path": str(py_file),
                                  "functions": funcs,
                                  "classes": classes,
                                  "priority": classes * 2 + funcs
                              })
                      except (SyntaxError, UnicodeDecodeError, OSError):
                          continue
              return sorted(modules, key=lambda x: x["priority"], reverse=True)
          
          # Test
          packages = get_package_dirs()
          print(f"Found packages: {packages}")
          assert "sample_pkg" in packages, f"Expected sample_pkg in {packages}"
          
          modules = find_python_modules(packages)
          print(f"Found modules: {[m['path'] for m in modules]}")
          assert len(modules) >= 2, f"Expected at least 2 modules, got {len(modules)}"
          
          print("✅ Module discovery logic works correctly")
          PYTEST
          
          # Cleanup
          rm -rf sample_pkg

  summary:
    name: CI Summary
    needs: [lint-workflows, validate-expressions, validate-repo-config, validate-repository-files, dry-run-generate-tests]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Check results
        run: |
          # shellcheck disable=SC2086
          {
            echo "## CI Results"
            echo ""
            echo "| Check | Status |"
            echo "|-------|--------|"
            echo "| Lint Workflows | ${{ needs.lint-workflows.result == 'success' && '✅' || '❌' }} |"
            echo "| Validate Expressions | ${{ needs.validate-expressions.result == 'success' && '✅' || '❌' }} |"
            echo "| Validate Repo Config | ${{ needs.validate-repo-config.result == 'success' && '✅' || '❌' }} |"
            echo "| Validate Repo Files | ${{ needs.validate-repository-files.result == 'success' && '✅' || '❌' }} |"
            echo "| Dry Run Generate Tests | ${{ needs.dry-run-generate-tests.result == 'success' && '✅' || '❌' }} |"
          } >> "$GITHUB_STEP_SUMMARY"
          
          # Fail if any job failed
          if [ "${{ needs.lint-workflows.result }}" != "success" ] || \
             [ "${{ needs.validate-expressions.result }}" != "success" ] || \
             [ "${{ needs.validate-repo-config.result }}" != "success" ] || \
             [ "${{ needs.validate-repository-files.result }}" != "success" ] || \
             [ "${{ needs.dry-run-generate-tests.result }}" != "success" ]; then
            echo ""
            echo "❌ CI failed - one or more checks did not pass"
            exit 1
          fi
          
          echo ""
          echo "✅ All CI checks passed"
